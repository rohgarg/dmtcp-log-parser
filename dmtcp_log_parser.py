#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.buffering import Buffer
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


KEYWORDS = {}


class DmtcpLogLanguageBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(DmtcpLogLanguageBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class DmtcpLogLanguageParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=DmtcpLogLanguageBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(DmtcpLogLanguageParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @graken()
    def _start_(self):

        def block0():
            self._msg_()
        self._positive_closure(block0)
        self._check_eof()

    @graken()
    def _msg_(self):
        with self._choice():
            with self._option():
                self._token('[')
                self.name_last_node('dmtcp_msg')
                self._pid_()
                self.name_last_node('dpid')
                self._token(']')
                self._msg_type_()
                self.name_last_node('dmtype')
                self._token('at')
                self._fname_()
                self.name_last_node('dfname')
                self._fext_()
                self.name_last_node('dfext')
                self._token(':')
                self._lnum_()
                self.name_last_node('dlnum')
                self._token('in')
                self._fnc_()
                self.name_last_node('dfnc')
                self._token('; REASON=')
                self._reason_()
                self.name_last_node('drea')

                def block9():
                    self._args_()
                self._closure(block9)
                self.name_last_node('dargs')
            with self._option():
                self._token('[')
                self.name_last_node('mtcp_msg')
                self._pid_()
                self.name_last_node('mpid')
                self._token(']')
                self._fname_()
                self.name_last_node('mfname')
                self._fext_()
                self.name_last_node('mfext')
                self._token(':')
                self._lnum_()
                self.name_last_node('mlnum')
                self._token('in')
                self._fnc_()
                self.name_last_node('mfnc')
                self._token('; REASON=')
                self._reason_()
                self.name_last_node('mrea')

                def block18():
                    self._args_()
                self._closure(block18)
                self.name_last_node('margs')
            self._error('no available options')
        self.ast._define(
            ['dargs', 'dfext', 'dfname', 'dfnc', 'dlnum', 'dmtcp_msg', 'dmtype', 'dpid', 'drea', 'margs', 'mfext', 'mfname', 'mfnc', 'mlnum', 'mpid', 'mrea', 'mtcp_msg'],
            []
        )

    @graken()
    def _pid_(self):
        self._pattern(r'\d+')

    @graken()
    def _msg_type_(self):
        with self._choice():
            with self._option():
                self._token('TRACE')
            with self._option():
                self._token('WARNING')
            with self._option():
                self._token('NOTE')
            with self._option():
                self._token('ERROR')
            self._error('expecting one of: ERROR NOTE TRACE WARNING')

    @graken()
    def _fname_(self):
        self._pattern(r'[a-zA-Z_]+')

    @graken()
    def _fext_(self):
        with self._choice():
            with self._option():
                self._token('.cpp')
            with self._option():
                self._token('.c')
            with self._option():
                self._token('.h')
            self._error('expecting one of: .c .cpp .h')

    @graken()
    def _lnum_(self):
        self._pattern(r'\d+')

    @graken()
    def _fnc_(self):
        self._pattern(r'[_a-zA-Z][_a-zA-Z0-9]*')

    @graken()
    def _reason_(self):
        with self._choice():
            with self._option():
                self._pattern(r"\'.+\'$")
            with self._option():
                self._pattern(r'.+$')
            self._error("expecting one of: .+$ \\'.+\\'$")

    @graken()
    def _args_(self):
        with self._choice():
            with self._option():
                self._dashed_line_()
                self.name_last_node('dl')
            with self._option():
                self._arg_val_pair_()
                self.name_last_node('avp')
            with self._option():
                self._connection_description_()
                self.name_last_node('cd')
            self._error('no available options')
        self.ast._define(
            ['avp', 'cd', 'dl'],
            []
        )

    @graken()
    def _dashed_line_(self):
        self._token('==================================================')

    @graken()
    def _connection_description_(self):
        self._pattern(r'.*->.*')

    @graken()
    def _arg_val_pair_(self):
        self._arg_()
        self.name_last_node('avpa')
        self._token('=')
        self._value_()
        self.name_last_node('avpv')
        self.ast._define(
            ['avpa', 'avpv'],
            []
        )

    @graken()
    def _arg_(self):
        self._pattern(r'(?!\[\d+\])[^=]*')

    @graken()
    def _value_(self):
        self._pattern(r'.*$')


class DmtcpLogLanguageSemantics(object):
    def start(self, ast):
        return ast

    def msg(self, ast):
        return ast

    def pid(self, ast):
        return ast

    def msg_type(self, ast):
        return ast

    def fname(self, ast):
        return ast

    def fext(self, ast):
        return ast

    def lnum(self, ast):
        return ast

    def fnc(self, ast):
        return ast

    def reason(self, ast):
        return ast

    def args(self, ast):
        return ast

    def dashed_line(self, ast):
        return ast

    def connection_description(self, ast):
        return ast

    def arg_val_pair(self, ast):
        return ast

    def arg(self, ast):
        return ast

    def value(self, ast):
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = DmtcpLogLanguageParser()
    return parser.parse(text, startrule, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from grako.util import asjson

    ast = generic_main(main, DmtcpLogLanguageParser, name='DmtcpLogLanguage')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
